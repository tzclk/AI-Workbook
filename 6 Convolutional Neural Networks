Convolutional Neural Networks
Machine learning on images


import pandas as pd
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt


​MNIST

from keras.datasets import mnist
(X_train, y_train), (X_test, y_test) = mnist.load_data('/tmp/mnist.npz')
X_train.shape
X_test.shape
X_train[0]
plt.imshow(X_train[0], cmap='gray')
X_train = X_train.reshape(-1, 28*28)
X_test = X_test.reshape(-1, 28*28)
X_train.shape
X_train = X_train.astype('float32')
X_test = X_test.astype('float32')
X_train /= 255.0
X_test /= 255.0
X_train[0]

from keras.utils.np_utils import to_categorical
y_train_cat = to_categorical(y_train)
y_test_cat = to_categorical(y_test)
y_train[0]
y_train_cat[0]
y_train_cat.shape
y_test_cat.shape


​Fully connected on images
from keras.models import Sequential
from keras.layers import Dense
import keras.backend as K
​
K.clear_session()
​
model = Sequential()
model.add(Dense(512, input_dim=28*28, activation='relu'))
model.add(Dense(256, activation='relu'))
model.add(Dense(128, activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(10, activation='softmax'))
model.compile(loss='categorical_crossentropy',
              optimizer='rmsprop',
              metrics=['accuracy'])
​
h = model.fit(X_train, y_train_cat, batch_size=128, epochs=10, verbose=1, validation_split=0.3)
plt.plot(h.history['acc'])
plt.plot(h.history['val_acc'])
plt.legend(['Training', 'Validation'])
plt.title('Accuracy')
plt.xlabel('Epochs')
test_accuracy = model.evaluate(X_test, y_test_cat)[1]
test_accuracy


​Tensor Math
A = np.random.randint(10, size=(2, 3, 4, 5))
B = np.random.randint(10, size=(2, 3))
A
A[0, 1, 0, 3]
B


​A random colored image

img = np.random.randint(255, size=(4, 4, 3), dtype='uint8')
img
plt.figure(figsize=(5, 5))
plt.subplot(221)
plt.imshow(img)
plt.title("All Channels combined")
​
plt.subplot(222)
plt.imshow(img[:, : , 0], cmap='Reds')
plt.title("Red channel")
​
plt.subplot(223)
plt.imshow(img[:, : , 1], cmap='Greens')
plt.title("Green channel")
​
plt.subplot(224)
plt.imshow(img[:, : , 2], cmap='Blues')
plt.title("Blue channel")
Tensor operations
2 * A
A + A
A.shape
B.shape
np.tensordot(A, B, axes=([0, 1], [0, 1]))
np.tensordot(A, B, axes=([0], [0])).shape


​1D convolution

a = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], dtype='float32')
b = np.array([-1, 1], dtype='float32')
c = np.convolve(a, b)
a
b
c
plt.subplot(211)
plt.plot(a, 'o-')
​
plt.subplot(212)
plt.plot(c, 'o-')
Image filters with convolutions
from scipy.ndimage.filters import convolve
from scipy.signal import convolve2d
from scipy import misc
img = misc.ascent()
img.shape
plt.imshow(img, cmap='gray')
h_kernel = np.array([[ 1,  2,  1],
                     [ 0,  0,  0],
                     [-1, -2, -1]])
​
plt.imshow(h_kernel, cmap='gray')
res = convolve2d(img, h_kernel)
​
plt.imshow(res, cmap='gray')
Convolutional neural networks
from keras.layers import Conv2D
img.shape
plt.figure(figsize=(5, 5))
plt.imshow(img, cmap='gray')
img_tensor = img.reshape((1, 512, 512, 1))
model = Sequential()
model.add(Conv2D(1, (3, 3), strides=(2,1), input_shape=(512, 512, 1)))
model.compile('adam', 'mse')
img_pred_tensor = model.predict(img_tensor)
img_pred_tensor.shape
img_pred = img_pred_tensor[0, :, :, 0]
plt.imshow(img_pred, cmap='gray')
weights = model.get_weights()
weights[0].shape
plt.imshow(weights[0][:, :, 0, 0], cmap='gray')
weights[0] = np.ones(weights[0].shape)
model.set_weights(weights)
img_pred_tensor = model.predict(img_tensor)
img_pred = img_pred_tensor[0, :, :, 0]
plt.imshow(img_pred, cmap='gray')
model = Sequential()
model.add(Conv2D(1, (3, 3), input_shape=(512, 512, 1), padding='same'))
model.compile('adam', 'mse')
​
img_pred_tensor = model.predict(img_tensor)
​
​
img_pred_tensor.shape
Pooling layers
from keras.layers import MaxPool2D, AvgPool2D
model = Sequential()
model.add(MaxPool2D((5, 5), input_shape=(512, 512, 1)))
model.compile('adam', 'mse')
img_pred = model.predict(img_tensor)[0, :, :, 0]
plt.imshow(img_pred, cmap='gray')
model = Sequential()
model.add(AvgPool2D((5, 5), input_shape=(512, 512, 1)))
model.compile('adam', 'mse')
img_pred = model.predict(img_tensor)[0, :, :, 0]
plt.imshow(img_pred, cmap='gray')
Final architecture
X_train = X_train.reshape(-1, 28, 28, 1)
X_test = X_test.reshape(-1, 28, 28, 1)
X_train.shape
from keras.layers import Flatten, Activation
K.clear_session()
​
model = Sequential()
​
model.add(Conv2D(32, (3, 3), input_shape=(28, 28, 1)))
model.add(MaxPool2D(pool_size=(2, 2)))
model.add(Activation('relu'))
​
model.add(Flatten())
​
model.add(Dense(128, activation='relu'))
​
model.add(Dense(10, activation='softmax'))
​
model.compile(loss='categorical_crossentropy',
              optimizer='rmsprop',
              metrics=['accuracy'])
model.summary()
model.fit(X_train, y_train_cat, batch_size=128,
          epochs=2, verbose=1, validation_split=0.3)
model.evaluate(X_test, y_test_cat)





​Exercise 1
You've been hired by a shipping company to overhaul the way they route mail, parcels and packages. They want to build an image recognition system capable of recognizing the digits in the zipcode on a package, so that it can be automatically routed to the correct location. You are tasked to build the digit recognition system. Luckily, you can rely on the MNIST dataset for the intial training of your model!

Build a deep convolutional neural network with at least two convolutional and two pooling layers before the fully connected layer.

Start from the network we have just built
Insert a Conv2D layer after the first MaxPool2D, give it 64 filters.
Insert a MaxPool2D after that one
Insert an Activation layer
retrain the model
does performance improve?
how many parameters does this new model have? More or less than the previous model? Why?
how long did this second model take to train? Longer or shorter than the previous model? Why?
did it perform better or worse than the previous model?
​
Exercise 2
Pleased with your performance with the digits recognition task, your boss decides to challenge you with a harder task. Their online branch allows people to upload images to a website that generates and prints a postcard that is shipped to destination. Your boss would like to know what images people are loading on the site in order to provide targeted advertising on the same page, so he asks you to build an image recognition system capable of recognizing a few objects. Luckily for you, there's a dataset ready made with a collection of labeled images. This is the Cifar 10 Dataset, a very famous dataset that contains images for 10 different categories:

airplane
automobile
bird
cat
deer
dog
frog
horse
ship
truck
In this exercise we will reach the limit of what you can achieve on your laptop and get ready for the next session on cloud GPUs.

Here's what you have to do:

load the cifar10 dataset using keras.datasets.cifar10.load_data()
display a few images, see how hard/easy it is for you to recognize an object with such low resolution
check the shape of X_train, does it need reshape?
check the scale of X_train, does it need rescaling?
check the shape of y_train, does it need reshape?
build a model with the following architecture, and choose the parameters and activation functions for each of the layers:
conv2d
conv2d
maxpool
conv2d
conv2d
maxpool
flatten
dense
output
compile the model and check the number of parameters
attempt to train the model with the optimizer of your choice. How fast does training proceed?
If training is too slow (as expected) stop the execution and move to the next session!
from keras.datasets import cifar10
​
